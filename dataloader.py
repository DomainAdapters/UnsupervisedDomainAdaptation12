# -*- coding: utf-8 -*-
"""DataLoader.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i9yHC6KOqeXykSemfhFsHglkR7V4UW6I
"""

import os
import torch
import torchvision
import torchvision.transforms as transforms
from PIL import Image
import torchvision.transforms.functional as TF
from torch.utils.data import Dataset
import random
import numpy as np
import matplotlib.pyplot as plt


def pil_loader(path): # we will use this to open all both kind of images converting them to RGB format
    with open(path, 'rb') as f:
        img = Image.open(f)
        return img.convert('RGB')

IMG_EXTENSIONS = [
    '.jpg', '.JPG', '.jpeg', '.JPEG',
    '.png', '.PNG', '.ppm', '.PPM', '.bmp', '.BMP',
]

def is_image_file(filename):
    return any(filename.endswith(extension) for extension in IMG_EXTENSIONS)

def make_sync_dataset(root, label, ds_name='synROD'):
    images = []

    with open(label, 'r') as labeltxt:
        for line in labeltxt:
            data = line.strip().split(' ')
            if not is_image_file(data[0]):
                continue
            if ds_name == 'ROD':
                path = os.path.join(root, '???-washington', data[0])
            else:
                path = os.path.join(root, data[0])

            if ds_name == 'synROD':
                path_rgb = path.replace('***', 'rgb')
                path_depth = path.replace('***', 'depth')
            elif ds_name == 'ROD':
                path_rgb = path.replace('***', 'crop')
                path_rgb = path_rgb.replace('???', 'rgb')
                path_depth = path.replace('***', 'depthcrop')
                path_depth = path_depth.replace('???', 'surfnorm')
            else:
                raise ValueError('Unknown dataset {}. Known datasets are synROD, ROD'.format(ds_name))
            gt = int(data[1])
            item = (path_rgb, path_depth, gt)
            images.append(item)
        return images

class MyTransformer(object):

    def __init__(self, crop, flip, discrete = True):
      super(MyTransformer, self).__init__()
      self.crop = crop # use a custom one because the crop should be the same for rgb and depth
      self.flip = flip
      self.angles = [0, 90, 180, 270] # as proved in the paper "Unsupervised Representation Learning by Predicting Image Rotation" these are the rotation angles that best increases 
                                      # the accuracy of the model.
      self.discrete = discrete
    
    def __call__(self, img, rot_disc=None, rot_cont = None, discrete = True):
      img = TF.resize(img, (256, 256))
      if self.flip:
        img = TF.hflip(img)
      # we do not use the RandomCrop class because we cant the same cropping both in rgb image and in depth image

      #display(img)
      if rot_disc is not None and self.discrete: # this "rot" will be index associated to a specific rotation of the list "angles"
        img = TF.rotate(img, self.angles[rot_disc])
      elif self.discrete == False and rot_cont is not None:
        img = TF.rotate(img, rot_cont)
      img = TF.crop(img, self.crop[0], self.crop[1], 224, 224)
      #img.save("image.png", "png")
      #display(img)
      img = TF.to_tensor(img)
      img = TF.normalize(img, [0.485, 0.456, 0.406], [0.229, 0.224, 0.225]) # in this way the network receives data normalized data w.r.t. mean and std evaluated on the values inside the tensors
      #display(img)
      return img

class MyDataset(Dataset):
  def __init__(self, label_path, fold_name = "synROD", rotate = False,  transform = None, discrete = True):
    self.img_path = "/content/ROD-synROD"
    self.label_path = label_path
    self.fold_name = fold_name
    img_path = os.path.join(self.img_path, self.fold_name)
    imgs =  make_sync_dataset(img_path,self.label_path, ds_name = fold_name)
    self.imgs = imgs
    self.transform = transform
    self.rotate = rotate
    self.discrete = discrete
  def __getitem__(self, index):
    path_rgb, path_depth, labels = self.imgs[index] # each index corresponds to a specific item i.e. a tuple containing paths and label
    img_rgb = pil_loader(path_rgb)
    img_depth = pil_loader(path_depth)
    rot_rgb = None
    rot_depth = None

    if self.transform is not None: 
      img_rgb.transform(img_rgb) # here i'm applying my custom transformation to the images
      img_depth.transform(img_depth)
    else:
      top = random.randint(0, 256 - 224) # why 256-224? Because we want that the final image has height=224 and width=224 .
      left = random.randint(0, 256 - 224)
      self.flip = random.choice([True, False])
      transform = MyTransformer([top, left], self.flip, self.discrete)
      if self.rotate and self.discrete:
        rot_rgb = random.choice([0,1,2,3])
        rot_depth = random.choice([0,1,2,3])
        img_rgb = transform(img_rgb, rot_rgb)
        img_depth = transform(img_depth, rot_depth)
        rel_rot = rot_depth - rot_rgb
        if rel_rot <0 :
          rel_rot +=4
          # it enters but does not make the integer of the rotation as a positive number
          
        return img_rgb, img_depth, labels, rel_rot

        
      if self.discrete == False:
        # print("i'm in")
        # randomly choosing an angle in a continuous interval giving the same probability to all the values
        rot_rgb = int(random.uniform(0.0, 360.0))
        rot_depth = int(random.uniform(0.0, 360.0))
        rad_angle = (rot_depth - rot_rgb)*2*np.pi/360
        rad_angle = torch.tensor(rad_angle)
        img_rgb = transform(img_rgb, rot_disc = None, rot_cont = rot_rgb)
        img_depth = transform(img_depth, rot_disc = None, rot_cont = rot_depth)
        return img_rgb, img_depth, labels, torch.cos(rad_angle), torch.sin(rad_angle) #np.cos(rad_angle).item(), np.sin(rad_angle).item()
      img_rgb = transform(img_rgb)
      img_depth = transform(img_depth)
      return img_rgb, img_depth, labels
    
  def __len__(self): 
    return len(self.imgs)

    
test_transform = MyTransformer([int((256 - 224) / 2), int((256 - 224) / 2)], False)

syn_Rod_evaluation_Rot = MyDataset("./ROD-synROD/synROD/synARID_50k-split_sync_test1.txt", rotate = True, fold_name = "synROD", transform=test_transform)

print(syn_Rod_evaluation_Rot.__getitem__(5000))



